

// autoLogin false until we resolve if we can automatically login

import { createSignal } from "solid-js"
import { createWs } from "./socket"
import { bufferToHex } from "./encode"

// if we succeed, we set the token
export const [tryLogin, setTryLogin] = createSignal(false)
export const [token, setToken] = createSignal<string>('')
export const [user, setUser] = createSignal<string>('')
export const  [security, setSecurity] = createSignal<Security>()
export const [error, setError] = createSignal("")
export const isMobile: boolean = (navigator as any)?.userAgentData?.mobile ?? false;
import * as bip39 from 'bip39'
import * as nacl from 'tweetnacl'

import { Buffer } from 'buffer'
// @ts-ignore
window.Buffer = Buffer;

export const  generatePassPhrase = () => bip39.generateMnemonic() 

// user name here needs to identify the domain that's tracking it?
// otherwise it won't be unique.
// we could simply use the hash of the private key, but then it could never be changed or revoked. certificate transparency offers solutions here? can datagrove sign the domain?
// 
export interface xx {
    username: string
}
export interface DeviceCertificate {
    username: string
    deviceName: string
    publicKey: JsonWebKey
    expires: number
    usefor: string[]
}
export interface Security {
    username: string
    deviceName: string 
    privateKey: JsonWebKey
    publicKey: JsonWebKey
    // the certificate is expiration date, username, devicename, device public key signed by the user signing key
    // the user key is generated by the secret phrase.
    certificate: string
}
// generate a self signed certificate that identifies the user 
// signature is generated from the passphrase
export function CertifyUser(passphrase: string) {
  const seed = bip39.mnemonicToSeedSync(passphrase).subarray(0, 32)
  const kp = nacl.sign.keyPair.fromSeed(seed)

  return bufferToHex(kp.publicKey) 
}

// generate a self signed certificate that identifies the device
export function CertifyDevice(){
}

async function  tryToLogin(){
   const a =  localStorage.getItem('security') 
   if (a) {
        const s = JSON.parse(a) as Security
        setSecurity(s)
        if (s.username && s.deviceName) {
            const key = await crypto.subtle.importKey(
                "jwk",
                s.privateKey,
                {
                  name: "ECDSA",
                  namedCurve: "P-256",
                },
                true,
                ["sign", "verify"]
              );

            // import the private key 
            // we have enough information to try to login
            // we get a challenge from the server, maybe send this immediately on websocket connection. we can use chained hashes potentially to make it faster (send the hash of the previous challenge)
            const ws = createWs()
            const dataBuffer = new TextEncoder().encode(ws.challenge);

            // Sign the data using the private key
            const signatureBuffer = await crypto.subtle.sign(
              {
                name: 'RSASSA-PKCS1-v1_5',
              },
              key,
              dataBuffer
            );
            const signatureArray = new Uint8Array(signatureBuffer);
            const r = await ws.rpc<{token: string}>('autologin',{
                user: s.username,
                device: s.deviceName,
                signature: signatureArray
            })
            if (r.token) {
                setToken(r.token)
                setUser(s.username)
                setTryLogin(true)
                return
            }
        }

        setTryLogin(true)
   }
   // generate a device identity
   let keyPair = await window.crypto.subtle.generateKey(
    {
      name: "ECDSA",
      namedCurve: "P-384",
    },
    true,
    ["sign", "verify"]
  );
  const publicKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey);
  const privateKeyJwk= await window.crypto.subtle.exportKey("jwk", keyPair.privateKey);
  let x : Security = {
      privateKey: privateKeyJwk,
      publicKey: publicKeyJwk,
      deviceName: "",
      username: "",
      certificate: "",
  }
  localStorage.setItem('security', JSON.stringify(x));

   // fail the autologin, no information to go on.
   setTryLogin(false)
   
}
tryToLogin()

