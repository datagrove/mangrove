
export class Cellx<T>  {
    signal: Signal<T|undefined>
    state: Signal<CellState>
    error_: SyntaxError[] = []
    constructor(
        public name: string,
        public rmw: ReaderWriter<any>,
        public options: CellOptions,
    ){
        
        this.signal  = createSignal<T|undefined>()
        this.state = createSignal<CellState>(CellState.loading)     
    }

    setValue(t: T){
        this.rmw.update(this.name, t as any)
    }

    operator() {
        return this.signal[0]()
    }
}



export function createCells<T extends CellOptionMap>(rmw: ReaderWriter<any>,  col: T): CellMap<T> {
    const r: any = {}
    Object.keys(col).forEach(k => {
        var o  = new Cell(k, rmw, col[k])
        r[k] = o
    })
    return r
}







// just a store + resource?
// can sqlc use json serialization?
interface ReaderWriter<T> {
    update(key: string, value: T) : void
    addListener(key: string, cb: (v: T) => void):void
    removeListener(key: string):void
    refresh(): void
    loading: Signal<boolean>
    error: Signal<string|undefined>
}

// when this updates, it needs to signal all its cells
// or it could be more clever and diff against the previous values.

type Notify<T> =  (x: T)=>void
export class Listener<T> {
    listener = new Set<Notify<T>>()
    addListener(fn: Notify<T>) {
        this.listener.add(fn)
    }
    removeListener(fn: Notify<T>) {
        this.listener.delete(fn)
    }
    notify(v: T) {
        this.listener.forEach((fn) => fn(v))
    }
}
export class DbReaderWriter<T>  implements ReaderWriter<T>  {
    cache: T|undefined = undefined
    error: Signal<string|undefined> = createSignal(undefined)
    loading: Signal<boolean> = createSignal(false)
    constructor(public ws: Ws, public table: TableDesc) {
        super()
    
        this.refresh()
    }
    // merge with the previous value
    // we can't update if still loading.
    async update(key: string, value: T) {
        this.cache = {
            ...this.cache,
            [key]: value
        } as T
        this.ws.rpc("update", {
            table: this.table.name,
            key: this.table.primarykey,
            value,
        })
    }
    async refresh(){
        
    }
}
export function createUpdater(ws: Ws, table: TableDesc) {
    const upd = new DbReaderWriter(ws,table)
    return createCells(upd, table.columns)
}





// can this just implement signal? how is a lens any different?
// export interface Lens<T = any> {
//     addListener(fn: (v: T) => void) : void
//     set(v: T) : void 
// }




// a Cell is a [celloption, lens] with error tracking.
// you can't send it to workers, you need to rebuild on the other side
// but mostly a cell will only live in the main thread.

// maybe should be enum?
enum CellState {
    loading,
    error,
    available,
}

// maybe this should be a function returning a getter and a setter?
// its more like a resource, since it has a loading state
// solid uses () for get value. it returns the mutator from createResource
// potentially we could implement refresh as well, since most databases don't support streaming
// maybe cells could know they are part of a tuple and store that RMW style.




    

    // async set(ts: string) : void{
    //     console.log("commit", ts)
    //     setV(ts)
    // }
    // clearErrors() {
    //     setErr(undefined)
    // }

    // setError: (s: string) => {
    //     setErr([{ message: s, start: 0, end: 0 }])
    // },
    // listen: (cb: (val: string) => void) => {
    //     // not called.
    // },
    // value: () => v()
    


    // setValue(s: string): Promise<void>
    // listen(cb: (v: string) => void): void
    // value(): string
    // setError(s: string): void
    // error(): undefined | SyntaxError[]
    // clearErrors(): void

    // use array here so we can point to it? is there a cheaper way?
    //let v: string[] = [props?.default ?? ""]


class Client {
    shared: SendToWorker | undefined

    makeRpc<P, R>(method: string) {
        return async (x: P) => await this.shared?.rpc<R>(method, x)
    }
}
// const cl = new Client()
// async function init() {
//     cl.shared = await SendToWorker.shared(new Shared)
// }
// init()

export const watch = cl.makeRpc<Watch, number>('watch')
export const update = cl.makeRpc<Tx, void>('updateTx')
export const read = cl.makeRpc<Tx, Uint8Array[]>('readTx')
export const commit = cl.makeRpc<number, void>('commitTx')
export const unwatch = cl.makeRpc<number, void>('unwatch')

    /*
    s.set('begin', async (params: any): Promise<number> => st.begin())
    s.set('updateTx', async (params: Write): Promise<void> => {
      //st.tx.get(params.tx)?.update(params)
    })

    s.set('readTx', async (params: Read): Promise<PageRef[]> => {
      // return st.tx.get(params.tx)?.read(params) ?? []
    })


    s.set('commitTx', async (params: number): Promise<void> => {
      st.tx.get(params)?.commit()
    })

    // subscriptions act like an advisory lock; if the range has been updated then we send a notification

    s.set('watch', async (params: Watch): Promise<number> => {
      st.watch.set(++st.nextWatch, params)
      // more to do - contact server etc
      return st.nextWatch
    })
    s.set('unwatch', async (params: number): Promise<void> => {
      st.watch.delete(params)
    })
    */