
type ZodAny =  typeof z.ZodObject<any>
type Service = {
    [key: string]: Api<any,any>
}

interface Api<P,R> {
    params(x: any): boolean
    result(x: any): boolean
    exec(a: P): R 
}

const User = z.object({
    username: z.string(),
  });
type Usertype = z.infer<typeof User>

function makeParser<P,T>(zod: any,ret?: any, exe: (u: P)=>Promise<T>) : (x: any)=>boolean {
    return (x: any) : boolean => {    
        const o = zod.safeParse(x)
        return o.success
    }
}

const a1 = makeParser(User,User, async (u: Usertype )=> u )



// function api<P,R>(zodParams: P,zodResult?: R, fn) : Api{
//     return {
//         params: (x: any) => P.safeParse(x)
//     }
// }






export const HostService = {
    "sub": api (z.object({
        "path": z.string(),
        "start": z.number(),
    }) )
    "unsub": z.object({
        "path": z.string(),
    }),
}

export const TabService = {
    "update": z.object({
        "path": z.string(),
        "ops": z.array(z.object({
            "op": z.any(),
        }))
    }),
}

// when first subscribing we might want a more efficient thing than every op
export const LocalStateService : Service= {
    "sub": z.object({
        "path": z.string(),
    })


}

export const KeeperService = {
    "read": [z.object({
        "path": z.string(),
        "start": z.number(),
        "end": z.number(),
    }), ]
}
export const KeeperHostService = {

    // async service, does 
    "write": z.object({
        "path": z.string(),
        "at": z.number(),
        "a": z.any(),
    })

}