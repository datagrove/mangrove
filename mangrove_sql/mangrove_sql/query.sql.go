// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package mangrove_sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveDevice = `-- name: ApproveDevice :exec
insert into mg.device_org (device,oid) values ($1, $2)
`

type ApproveDeviceParams struct {
	Device int64 `json:"device"`
	Oid    int64 `json:"oid"`
}

func (q *Queries) ApproveDevice(ctx context.Context, arg ApproveDeviceParams) error {
	_, err := q.db.Exec(ctx, approveDevice, arg.Device, arg.Oid)
	return err
}

const availableName = `-- name: AvailableName :one
select count(*) from mg.org where name = $1
`

func (q *Queries) AvailableName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, availableName, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteCredential = `-- name: DeleteCredential :exec
delete from mg.credential where cid = $1
`

func (q *Queries) DeleteCredential(ctx context.Context, cid []byte) error {
	_, err := q.db.Exec(ctx, deleteCredential, cid)
	return err
}

const deleteDevice = `-- name: DeleteDevice :exec
delete from mg.device where device = $1
`

func (q *Queries) DeleteDevice(ctx context.Context, device int64) error {
	_, err := q.db.Exec(ctx, deleteDevice, device)
	return err
}

const getDevice = `-- name: GetDevice :one
select device, webauthn from mg.device where device = $1
`

func (q *Queries) GetDevice(ctx context.Context, device int64) (MgDevice, error) {
	row := q.db.QueryRow(ctx, getDevice, device)
	var i MgDevice
	err := row.Scan(&i.Device, &i.Webauthn)
	return i, err
}

const insertDevice = `-- name: InsertDevice :exec
insert into mg.device (device, webauthn) values ($1, $2)
`

type InsertDeviceParams struct {
	Device   int64  `json:"device"`
	Webauthn string `json:"webauthn"`
}

func (q *Queries) InsertDevice(ctx context.Context, arg InsertDeviceParams) error {
	_, err := q.db.Exec(ctx, insertDevice, arg.Device, arg.Webauthn)
	return err
}

const insertLock = `-- name: InsertLock :exec
insert into mg.dblock (db, name, serial) values ($1, $2, 1)
`

type InsertLockParams struct {
	Db   int64  `json:"db"`
	Name []byte `json:"name"`
}

// if value is 1, then we need to insert
func (q *Queries) InsertLock(ctx context.Context, arg InsertLockParams) error {
	_, err := q.db.Exec(ctx, insertLock, arg.Db, arg.Name)
	return err
}

const insertOrg = `-- name: InsertOrg :one
insert into mg.org (oid,did,name,recovery) values ($1, $2, $3, $4) returning oid
`

type InsertOrgParams struct {
	Oid      int64  `json:"oid"`
	Did      string `json:"did"`
	Name     string `json:"name"`
	Recovery []byte `json:"recovery"`
}

func (q *Queries) InsertOrg(ctx context.Context, arg InsertOrgParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertOrg,
		arg.Oid,
		arg.Did,
		arg.Name,
		arg.Recovery,
	)
	var oid int64
	err := row.Scan(&oid)
	return oid, err
}

const insertPasskey = `-- name: InsertPasskey :exec
insert into mg.credential (cid, oid, name, password_hash, value) values ($1, $2, $3, $4, $5)
`

type InsertPasskeyParams struct {
	Cid          []byte      `json:"cid"`
	Oid          int64       `json:"oid"`
	Name         pgtype.Text `json:"name"`
	PasswordHash []byte      `json:"password_hash"`
	Value        []byte      `json:"value"`
}

func (q *Queries) InsertPasskey(ctx context.Context, arg InsertPasskeyParams) error {
	_, err := q.db.Exec(ctx, insertPasskey,
		arg.Cid,
		arg.Oid,
		arg.Name,
		arg.PasswordHash,
		arg.Value,
	)
	return err
}

const insertPrefix = `-- name: InsertPrefix :exec
insert into mg.name_prefix (name,count) values ($1,0) on conflict do nothing
`

func (q *Queries) InsertPrefix(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, insertPrefix, name)
	return err
}

const namePrefix = `-- name: NamePrefix :one
select name, count from mg.name_prefix where name = $1
`

func (q *Queries) NamePrefix(ctx context.Context, name string) (MgNamePrefix, error) {
	row := q.db.QueryRow(ctx, namePrefix, name)
	var i MgNamePrefix
	err := row.Scan(&i.Name, &i.Count)
	return i, err
}

const read = `-- name: Read :many
select fid, start, data from mg.dbentry where fid = $1 and start between $2 and $3 order by start
`

type ReadParams struct {
	Fid     int64 `json:"fid"`
	Start   int64 `json:"start"`
	Start_2 int64 `json:"start_2"`
}

func (q *Queries) Read(ctx context.Context, arg ReadParams) ([]MgDbentry, error) {
	rows, err := q.db.Query(ctx, read, arg.Fid, arg.Start, arg.Start_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MgDbentry
	for rows.Next() {
		var i MgDbentry
		if err := rows.Scan(&i.Fid, &i.Start, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeDevice = `-- name: RevokeDevice :exec
delete from mg.device_org where device = $1 and oid = $2
`

type RevokeDeviceParams struct {
	Device int64 `json:"device"`
	Oid    int64 `json:"oid"`
}

func (q *Queries) RevokeDevice(ctx context.Context, arg RevokeDeviceParams) error {
	_, err := q.db.Exec(ctx, revokeDevice, arg.Device, arg.Oid)
	return err
}

const selectOrg = `-- name: SelectOrg :one
select oid, did, name, recovery from mg.org where oid = $1
`

func (q *Queries) SelectOrg(ctx context.Context, oid int64) (MgOrg, error) {
	row := q.db.QueryRow(ctx, selectOrg, oid)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Did,
		&i.Name,
		&i.Recovery,
	)
	return i, err
}

const selectOrgByName = `-- name: SelectOrgByName :one
select oid, did, name, recovery from mg.org where name = $1
`

func (q *Queries) SelectOrgByName(ctx context.Context, name string) (MgOrg, error) {
	row := q.db.QueryRow(ctx, selectOrgByName, name)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Did,
		&i.Name,
		&i.Recovery,
	)
	return i, err
}

const selectPasskey = `-- name: SelectPasskey :one
select cid, password_hash, oid, name, value from mg.credential where cid = $1
`

func (q *Queries) SelectPasskey(ctx context.Context, cid []byte) (MgCredential, error) {
	row := q.db.QueryRow(ctx, selectPasskey, cid)
	var i MgCredential
	err := row.Scan(
		&i.Cid,
		&i.PasswordHash,
		&i.Oid,
		&i.Name,
		&i.Value,
	)
	return i, err
}

const trim = `-- name: Trim :exec
delete from mg.dbentry where fid = $1 and start between $2 and $3
`

type TrimParams struct {
	Fid     int64 `json:"fid"`
	Start   int64 `json:"start"`
	Start_2 int64 `json:"start_2"`
}

func (q *Queries) Trim(ctx context.Context, arg TrimParams) error {
	_, err := q.db.Exec(ctx, trim, arg.Fid, arg.Start, arg.Start_2)
	return err
}

const updateLock = `-- name: UpdateLock :exec
update mg.dblock set serial = $3 where db = $1 and name = $2
`

type UpdateLockParams struct {
	Db     int64       `json:"db"`
	Name   []byte      `json:"name"`
	Serial pgtype.Int8 `json:"serial"`
}

func (q *Queries) UpdateLock(ctx context.Context, arg UpdateLockParams) error {
	_, err := q.db.Exec(ctx, updateLock, arg.Db, arg.Name, arg.Serial)
	return err
}

const updateOrg = `-- name: UpdateOrg :exec
update mg.org set did = $2, name = $3, recovery = $4 where oid = $1
`

type UpdateOrgParams struct {
	Oid      int64  `json:"oid"`
	Did      string `json:"did"`
	Name     string `json:"name"`
	Recovery []byte `json:"recovery"`
}

func (q *Queries) UpdateOrg(ctx context.Context, arg UpdateOrgParams) error {
	_, err := q.db.Exec(ctx, updateOrg,
		arg.Oid,
		arg.Did,
		arg.Name,
		arg.Recovery,
	)
	return err
}

const updatePrefix = `-- name: UpdatePrefix :one
update mg.name_prefix set count=count+1 where name = $1 returning count
`

func (q *Queries) UpdatePrefix(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, updatePrefix, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const write = `-- name: Write :exec
insert into mg.dbentry (fid, start, data) values ($1, $2, $3)
`

type WriteParams struct {
	Fid   int64  `json:"fid"`
	Start int64  `json:"start"`
	Data  []byte `json:"data"`
}

func (q *Queries) Write(ctx context.Context, arg WriteParams) error {
	_, err := q.db.Exec(ctx, write, arg.Fid, arg.Start, arg.Data)
	return err
}
