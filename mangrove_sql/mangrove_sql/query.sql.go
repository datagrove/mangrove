// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package mangrove_sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveDevice = `-- name: ApproveDevice :exec
insert into mg.device_org (device,oid) values ($1, $2)
`

type ApproveDeviceParams struct {
	Device int64
	Oid    int64
}

func (q *Queries) ApproveDevice(ctx context.Context, arg ApproveDeviceParams) error {
	_, err := q.db.Exec(ctx, approveDevice, arg.Device, arg.Oid)
	return err
}

const availableName = `-- name: AvailableName :one
select count(*) from mg.org where name = $1
`

func (q *Queries) AvailableName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, availableName, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDevice = `-- name: DeleteDevice :exec
delete from mg.device where device = $1
`

func (q *Queries) DeleteDevice(ctx context.Context, device int64) error {
	_, err := q.db.Exec(ctx, deleteDevice, device)
	return err
}

const getDevice = `-- name: GetDevice :one
select device, webauthn from mg.device where device = $1
`

func (q *Queries) GetDevice(ctx context.Context, device int64) (MgDevice, error) {
	row := q.db.QueryRow(ctx, getDevice, device)
	var i MgDevice
	err := row.Scan(&i.Device, &i.Webauthn)
	return i, err
}

const insertCredential = `-- name: InsertCredential :exec
insert into mg.credential (oid, name, type, value) values ($1, $2, $3, $4)
`

type InsertCredentialParams struct {
	Oid   int64
	Name  pgtype.Text
	Type  pgtype.Text
	Value []byte
}

func (q *Queries) InsertCredential(ctx context.Context, arg InsertCredentialParams) error {
	_, err := q.db.Exec(ctx, insertCredential,
		arg.Oid,
		arg.Name,
		arg.Type,
		arg.Value,
	)
	return err
}

const insertDevice = `-- name: InsertDevice :exec
insert into mg.device (device, webauthn) values ($1, $2)
`

type InsertDeviceParams struct {
	Device   int64
	Webauthn string
}

func (q *Queries) InsertDevice(ctx context.Context, arg InsertDeviceParams) error {
	_, err := q.db.Exec(ctx, insertDevice, arg.Device, arg.Webauthn)
	return err
}

const insertLock = `-- name: InsertLock :exec
insert into mg.dblock (db, name, serial) values ($1, $2, 1)
`

type InsertLockParams struct {
	Db   int64
	Name []byte
}

// if value is 1, then we need to insert
func (q *Queries) InsertLock(ctx context.Context, arg InsertLockParams) error {
	_, err := q.db.Exec(ctx, insertLock, arg.Db, arg.Name)
	return err
}

const insertOrg = `-- name: InsertOrg :one
insert into mg.org (
    name, is_user, password, hash_alg,email,mobile,pin,
    webauthn,totp,flags,totp_png,default_factor)
values ($1, $2, $3,$4,$5,$6,$7,$8,$9,$10,$11,$12) 
RETURNING oid
`

type InsertOrgParams struct {
	Name          string
	IsUser        bool
	Password      []byte
	HashAlg       pgtype.Text
	Email         pgtype.Text
	Mobile        pgtype.Text
	Pin           string
	Webauthn      string
	Totp          string
	Flags         int64
	TotpPng       []byte
	DefaultFactor int32
}

func (q *Queries) InsertOrg(ctx context.Context, arg InsertOrgParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertOrg,
		arg.Name,
		arg.IsUser,
		arg.Password,
		arg.HashAlg,
		arg.Email,
		arg.Mobile,
		arg.Pin,
		arg.Webauthn,
		arg.Totp,
		arg.Flags,
		arg.TotpPng,
		arg.DefaultFactor,
	)
	var oid int64
	err := row.Scan(&oid)
	return oid, err
}

const insertPrefix = `-- name: InsertPrefix :exec
insert into mg.name_prefix (name,count) values ($1,0) on conflict do nothing
`

func (q *Queries) InsertPrefix(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, insertPrefix, name)
	return err
}

const namePrefix = `-- name: NamePrefix :one
select name, count from mg.name_prefix where name = $1
`

func (q *Queries) NamePrefix(ctx context.Context, name string) (MgNamePrefix, error) {
	row := q.db.QueryRow(ctx, namePrefix, name)
	var i MgNamePrefix
	err := row.Scan(&i.Name, &i.Count)
	return i, err
}

const orgByEmail = `-- name: OrgByEmail :one
select oid, name, is_user, password, hash_alg, email, mobile, pin, webauthn, totp, flags, totp_png, default_factor from mg.org where email = $1
`

func (q *Queries) OrgByEmail(ctx context.Context, email pgtype.Text) (MgOrg, error) {
	row := q.db.QueryRow(ctx, orgByEmail, email)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Name,
		&i.IsUser,
		&i.Password,
		&i.HashAlg,
		&i.Email,
		&i.Mobile,
		&i.Pin,
		&i.Webauthn,
		&i.Totp,
		&i.Flags,
		&i.TotpPng,
		&i.DefaultFactor,
	)
	return i, err
}

const orgByPhone = `-- name: OrgByPhone :one
select oid, name, is_user, password, hash_alg, email, mobile, pin, webauthn, totp, flags, totp_png, default_factor from mg.org where mobile = $1
`

func (q *Queries) OrgByPhone(ctx context.Context, mobile pgtype.Text) (MgOrg, error) {
	row := q.db.QueryRow(ctx, orgByPhone, mobile)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Name,
		&i.IsUser,
		&i.Password,
		&i.HashAlg,
		&i.Email,
		&i.Mobile,
		&i.Pin,
		&i.Webauthn,
		&i.Totp,
		&i.Flags,
		&i.TotpPng,
		&i.DefaultFactor,
	)
	return i, err
}

const read = `-- name: Read :many
select fid, start, data from mg.dbentry where fid = $1 and start between $2 and $3 order by start
`

type ReadParams struct {
	Fid     int64
	Start   int64
	Start_2 int64
}

func (q *Queries) Read(ctx context.Context, arg ReadParams) ([]MgDbentry, error) {
	rows, err := q.db.Query(ctx, read, arg.Fid, arg.Start, arg.Start_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MgDbentry
	for rows.Next() {
		var i MgDbentry
		if err := rows.Scan(&i.Fid, &i.Start, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeDevice = `-- name: RevokeDevice :exec
delete from mg.device_org where device = $1 and oid = $2
`

type RevokeDeviceParams struct {
	Device int64
	Oid    int64
}

func (q *Queries) RevokeDevice(ctx context.Context, arg RevokeDeviceParams) error {
	_, err := q.db.Exec(ctx, revokeDevice, arg.Device, arg.Oid)
	return err
}

const selectCredential = `-- name: SelectCredential :many
select oid, id, name, type, value from mg.credential where oid = $1
`

func (q *Queries) SelectCredential(ctx context.Context, oid int64) ([]MgCredential, error) {
	rows, err := q.db.Query(ctx, selectCredential, oid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MgCredential
	for rows.Next() {
		var i MgCredential
		if err := rows.Scan(
			&i.Oid,
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOrg = `-- name: SelectOrg :one
select oid, name, is_user, password, hash_alg, email, mobile, pin, webauthn, totp, flags, totp_png, default_factor from mg.org where oid = $1
`

func (q *Queries) SelectOrg(ctx context.Context, oid int64) (MgOrg, error) {
	row := q.db.QueryRow(ctx, selectOrg, oid)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Name,
		&i.IsUser,
		&i.Password,
		&i.HashAlg,
		&i.Email,
		&i.Mobile,
		&i.Pin,
		&i.Webauthn,
		&i.Totp,
		&i.Flags,
		&i.TotpPng,
		&i.DefaultFactor,
	)
	return i, err
}

const selectOrgByName = `-- name: SelectOrgByName :one
select oid, name, is_user, password, hash_alg, email, mobile, pin, webauthn, totp, flags, totp_png, default_factor from mg.org where name = $1
`

func (q *Queries) SelectOrgByName(ctx context.Context, name string) (MgOrg, error) {
	row := q.db.QueryRow(ctx, selectOrgByName, name)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Name,
		&i.IsUser,
		&i.Password,
		&i.HashAlg,
		&i.Email,
		&i.Mobile,
		&i.Pin,
		&i.Webauthn,
		&i.Totp,
		&i.Flags,
		&i.TotpPng,
		&i.DefaultFactor,
	)
	return i, err
}

const trim = `-- name: Trim :exec
delete from mg.dbentry where fid = $1 and start between $2 and $3
`

type TrimParams struct {
	Fid     int64
	Start   int64
	Start_2 int64
}

func (q *Queries) Trim(ctx context.Context, arg TrimParams) error {
	_, err := q.db.Exec(ctx, trim, arg.Fid, arg.Start, arg.Start_2)
	return err
}

const updateLock = `-- name: UpdateLock :exec
update mg.dblock set serial = $3 where db = $1 and name = $2
`

type UpdateLockParams struct {
	Db     int64
	Name   []byte
	Serial pgtype.Int8
}

func (q *Queries) UpdateLock(ctx context.Context, arg UpdateLockParams) error {
	_, err := q.db.Exec(ctx, updateLock, arg.Db, arg.Name, arg.Serial)
	return err
}

const updateOrg = `-- name: UpdateOrg :exec
update mg.org set name = $2, is_user = $3, password = $4, hash_alg = $5, email = $6, mobile = $7, pin = $8, webauthn = $9, totp = $10, flags = $11,totp_png=$12,default_factor=$13 where oid=$1
`

type UpdateOrgParams struct {
	Oid           int64
	Name          string
	IsUser        bool
	Password      []byte
	HashAlg       pgtype.Text
	Email         pgtype.Text
	Mobile        pgtype.Text
	Pin           string
	Webauthn      string
	Totp          string
	Flags         int64
	TotpPng       []byte
	DefaultFactor int32
}

func (q *Queries) UpdateOrg(ctx context.Context, arg UpdateOrgParams) error {
	_, err := q.db.Exec(ctx, updateOrg,
		arg.Oid,
		arg.Name,
		arg.IsUser,
		arg.Password,
		arg.HashAlg,
		arg.Email,
		arg.Mobile,
		arg.Pin,
		arg.Webauthn,
		arg.Totp,
		arg.Flags,
		arg.TotpPng,
		arg.DefaultFactor,
	)
	return err
}

const updateOrgName = `-- name: UpdateOrgName :exec
update mg.org set name = $2 where oid=$1
`

type UpdateOrgNameParams struct {
	Oid  int64
	Name string
}

func (q *Queries) UpdateOrgName(ctx context.Context, arg UpdateOrgNameParams) error {
	_, err := q.db.Exec(ctx, updateOrgName, arg.Oid, arg.Name)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
update mg.org set password = $2 where oid = $1
`

type UpdatePasswordParams struct {
	Oid      int64
	Password []byte
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Oid, arg.Password)
	return err
}

const updatePrefix = `-- name: UpdatePrefix :one
update mg.name_prefix set count=count+1 where name = $1 returning count
`

func (q *Queries) UpdatePrefix(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, updatePrefix, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const write = `-- name: Write :exec
insert into mg.dbentry (fid, start, data) values ($1, $2, $3)
`

type WriteParams struct {
	Fid   int64
	Start int64
	Data  []byte
}

func (q *Queries) Write(ctx context.Context, arg WriteParams) error {
	_, err := q.db.Exec(ctx, write, arg.Fid, arg.Start, arg.Data)
	return err
}
