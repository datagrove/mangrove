// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package mangrove_sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveDevice = `-- name: ApproveDevice :exec
insert into mg.device_org (device,oid) values ($1, $2)
`

type ApproveDeviceParams struct {
	Device int64 `json:"device"`
	Oid    int64 `json:"oid"`
}

func (q *Queries) ApproveDevice(ctx context.Context, arg ApproveDeviceParams) error {
	_, err := q.db.Exec(ctx, approveDevice, arg.Device, arg.Oid)
	return err
}

const availableName = `-- name: AvailableName :one
select count(*) from mg.org where name = $1
`

func (q *Queries) AvailableName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, availableName, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteCredential = `-- name: DeleteCredential :exec
delete from mg.credential where cid = $1
`

func (q *Queries) DeleteCredential(ctx context.Context, cid []byte) error {
	_, err := q.db.Exec(ctx, deleteCredential, cid)
	return err
}

const deleteDevice = `-- name: DeleteDevice :exec
delete from mg.device where device = $1
`

func (q *Queries) DeleteDevice(ctx context.Context, device int64) error {
	_, err := q.db.Exec(ctx, deleteDevice, device)
	return err
}

const deletePush = `-- name: DeletePush :exec
delete from mg.push where sid = $1 and oid = $2
`

type DeletePushParams struct {
	Sid int64 `json:"sid"`
	Oid int64 `json:"oid"`
}

func (q *Queries) DeletePush(ctx context.Context, arg DeletePushParams) error {
	_, err := q.db.Exec(ctx, deletePush, arg.Sid, arg.Oid)
	return err
}

const getDevice = `-- name: GetDevice :one
select device, webauthn from mg.device where device = $1
`

func (q *Queries) GetDevice(ctx context.Context, device int64) (MgDevice, error) {
	row := q.db.QueryRow(ctx, getDevice, device)
	var i MgDevice
	err := row.Scan(&i.Device, &i.Webauthn)
	return i, err
}

const insertCredential = `-- name: InsertCredential :exec
insert into mg.credential (cid, oid, name, value) values ($1, $2, $3, $4)
`

type InsertCredentialParams struct {
	Cid   []byte      `json:"cid"`
	Oid   int64       `json:"oid"`
	Name  pgtype.Text `json:"name"`
	Value []byte      `json:"value"`
}

func (q *Queries) InsertCredential(ctx context.Context, arg InsertCredentialParams) error {
	_, err := q.db.Exec(ctx, insertCredential,
		arg.Cid,
		arg.Oid,
		arg.Name,
		arg.Value,
	)
	return err
}

const insertDevice = `-- name: InsertDevice :exec
insert into mg.device (device, webauthn) values ($1, $2)
`

type InsertDeviceParams struct {
	Device   int64  `json:"device"`
	Webauthn string `json:"webauthn"`
}

func (q *Queries) InsertDevice(ctx context.Context, arg InsertDeviceParams) error {
	_, err := q.db.Exec(ctx, insertDevice, arg.Device, arg.Webauthn)
	return err
}

const insertLock = `-- name: InsertLock :exec
insert into mg.dblock (db, name, serial) values ($1, $2, 1)
`

type InsertLockParams struct {
	Db   int64  `json:"db"`
	Name []byte `json:"name"`
}

// if value is 1, then we need to insert
func (q *Queries) InsertLock(ctx context.Context, arg InsertLockParams) error {
	_, err := q.db.Exec(ctx, insertLock, arg.Db, arg.Name)
	return err
}

const insertOrg = `-- name: InsertOrg :one
insert into mg.org (oid,did,name,notify) values ($1, $2, $3, $4) returning oid
`

type InsertOrgParams struct {
	Oid    int64       `json:"oid"`
	Did    pgtype.Text `json:"did"`
	Name   string      `json:"name"`
	Notify []byte      `json:"notify"`
}

func (q *Queries) InsertOrg(ctx context.Context, arg InsertOrgParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertOrg,
		arg.Oid,
		arg.Did,
		arg.Name,
		arg.Notify,
	)
	var oid int64
	err := row.Scan(&oid)
	return oid, err
}

const insertPrefix = `-- name: InsertPrefix :exec
insert into mg.name_prefix (name,count) values ($1,0) on conflict do nothing
`

func (q *Queries) InsertPrefix(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, insertPrefix, name)
	return err
}

const insertPush = `-- name: InsertPush :exec
select sid, oid, mute from mg.push where sid = $1
`

func (q *Queries) InsertPush(ctx context.Context, sid int64) error {
	_, err := q.db.Exec(ctx, insertPush, sid)
	return err
}

const namePrefix = `-- name: NamePrefix :one
select name, count from mg.name_prefix where name = $1
`

func (q *Queries) NamePrefix(ctx context.Context, name string) (MgNamePrefix, error) {
	row := q.db.QueryRow(ctx, namePrefix, name)
	var i MgNamePrefix
	err := row.Scan(&i.Name, &i.Count)
	return i, err
}

const read = `-- name: Read :many
select fid, start, data from mg.dbentry where fid = $1 and start between $2 and $3 order by start
`

type ReadParams struct {
	Fid     int64 `json:"fid"`
	Start   int64 `json:"start"`
	Start_2 int64 `json:"start_2"`
}

func (q *Queries) Read(ctx context.Context, arg ReadParams) ([]MgDbentry, error) {
	rows, err := q.db.Query(ctx, read, arg.Fid, arg.Start, arg.Start_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MgDbentry
	for rows.Next() {
		var i MgDbentry
		if err := rows.Scan(&i.Fid, &i.Start, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeDevice = `-- name: RevokeDevice :exec
delete from mg.device_org where device = $1 and oid = $2
`

type RevokeDeviceParams struct {
	Device int64 `json:"device"`
	Oid    int64 `json:"oid"`
}

func (q *Queries) RevokeDevice(ctx context.Context, arg RevokeDeviceParams) error {
	_, err := q.db.Exec(ctx, revokeDevice, arg.Device, arg.Oid)
	return err
}

const selectCredential = `-- name: SelectCredential :one
select cid, oid, name, value from mg.credential where cid = $1
`

func (q *Queries) SelectCredential(ctx context.Context, cid []byte) (MgCredential, error) {
	row := q.db.QueryRow(ctx, selectCredential, cid)
	var i MgCredential
	err := row.Scan(
		&i.Cid,
		&i.Oid,
		&i.Name,
		&i.Value,
	)
	return i, err
}

const selectCredentialByOid = `-- name: SelectCredentialByOid :many
select cid, oid, name, value from mg.credential where oid = $1
`

func (q *Queries) SelectCredentialByOid(ctx context.Context, oid int64) ([]MgCredential, error) {
	rows, err := q.db.Query(ctx, selectCredentialByOid, oid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MgCredential
	for rows.Next() {
		var i MgCredential
		if err := rows.Scan(
			&i.Cid,
			&i.Oid,
			&i.Name,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOrg = `-- name: SelectOrg :one
select oid, did, name, private_key, notify from mg.org where oid = $1
`

func (q *Queries) SelectOrg(ctx context.Context, oid int64) (MgOrg, error) {
	row := q.db.QueryRow(ctx, selectOrg, oid)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Did,
		&i.Name,
		&i.PrivateKey,
		&i.Notify,
	)
	return i, err
}

const selectOrgByName = `-- name: SelectOrgByName :one
select oid, did, name, private_key, notify from mg.org where name = $1
`

func (q *Queries) SelectOrgByName(ctx context.Context, name string) (MgOrg, error) {
	row := q.db.QueryRow(ctx, selectOrgByName, name)
	var i MgOrg
	err := row.Scan(
		&i.Oid,
		&i.Did,
		&i.Name,
		&i.PrivateKey,
		&i.Notify,
	)
	return i, err
}

const selectPush = `-- name: SelectPush :many
select mute, notify from mg.push join mg.org on (mg.push.oid = mg.org.oid)  where sid = $1
`

type SelectPushRow struct {
	Mute   []byte `json:"mute"`
	Notify []byte `json:"notify"`
}

func (q *Queries) SelectPush(ctx context.Context, sid int64) ([]SelectPushRow, error) {
	rows, err := q.db.Query(ctx, selectPush, sid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectPushRow
	for rows.Next() {
		var i SelectPushRow
		if err := rows.Scan(&i.Mute, &i.Notify); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trim = `-- name: Trim :exec
delete from mg.dbentry where fid = $1 and start between $2 and $3
`

type TrimParams struct {
	Fid     int64 `json:"fid"`
	Start   int64 `json:"start"`
	Start_2 int64 `json:"start_2"`
}

func (q *Queries) Trim(ctx context.Context, arg TrimParams) error {
	_, err := q.db.Exec(ctx, trim, arg.Fid, arg.Start, arg.Start_2)
	return err
}

const updateCredential = `-- name: UpdateCredential :exec
update mg.credential set  value = $2 where cid = $1
`

type UpdateCredentialParams struct {
	Cid   []byte `json:"cid"`
	Value []byte `json:"value"`
}

func (q *Queries) UpdateCredential(ctx context.Context, arg UpdateCredentialParams) error {
	_, err := q.db.Exec(ctx, updateCredential, arg.Cid, arg.Value)
	return err
}

const updateLock = `-- name: UpdateLock :exec
update mg.dblock set serial = $3 where db = $1 and name = $2
`

type UpdateLockParams struct {
	Db     int64       `json:"db"`
	Name   []byte      `json:"name"`
	Serial pgtype.Int8 `json:"serial"`
}

func (q *Queries) UpdateLock(ctx context.Context, arg UpdateLockParams) error {
	_, err := q.db.Exec(ctx, updateLock, arg.Db, arg.Name, arg.Serial)
	return err
}

const updateOrg = `-- name: UpdateOrg :exec
update mg.org set did = $2, name = $3, notify = $4 where oid = $1
`

type UpdateOrgParams struct {
	Oid    int64       `json:"oid"`
	Did    pgtype.Text `json:"did"`
	Name   string      `json:"name"`
	Notify []byte      `json:"notify"`
}

func (q *Queries) UpdateOrg(ctx context.Context, arg UpdateOrgParams) error {
	_, err := q.db.Exec(ctx, updateOrg,
		arg.Oid,
		arg.Did,
		arg.Name,
		arg.Notify,
	)
	return err
}

const updatePrefix = `-- name: UpdatePrefix :one
update mg.name_prefix set count=count+1 where name = $1 returning count
`

func (q *Queries) UpdatePrefix(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, updatePrefix, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const write = `-- name: Write :exec
insert into mg.dbentry (fid, start, data) values ($1, $2, $3)
`

type WriteParams struct {
	Fid   int64  `json:"fid"`
	Start int64  `json:"start"`
	Data  []byte `json:"data"`
}

func (q *Queries) Write(ctx context.Context, arg WriteParams) error {
	_, err := q.db.Exec(ctx, write, arg.Fid, arg.Start, arg.Data)
	return err
}
